



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="../mdzdoc-css/main.css" type="text/css" charset="utf-8">
    <title>API</title>
    <meta name="description" content="">
  </head>
  <body>
    <!-- Toggles Navigation -->
    <div id="toc-toggle" class="">
      <div class="bar topbar"></div>
      <div class="bar"></div>
      <div class="bar botbar"></div>
    </div>
    <div class="twocol">
      <div class="toc toc-hidden">
        <ul>
          <li><span><a href="../index.html">Jhydro</a></span></li><li class="caret"><span class="selected"><a href="index.html">API</a></span><ul><li><span><a href="hash.html">General Purpose Hashing</a></span></li><li><span><a href="kdf.html">Key Derivation</a></span></li><li><span><a href="kx.html">Key Exchange</a></span></li><li><span><a href="pwhash.html">Password Hashing</a></span></li><li><span><a href="sign.html">Public Key Signing</a></span></li><li><span><a href="random.html">Random Number Generation</a></span></li><li><span><a href="secretbox.html">Symmetric Encryption</a></span></li><li><span><a href="util.html">Utilities</a></span></li></ul></li>
        </ul>
      </div>
      <div class="content-wrapper">
        <h1>API</h1>
        <div class="prevnext-bar">
          <span class="prev"><a href="../index.html"><span class="prevnext-text">Jhydro</span></a></span>
          <span class="next"><a href="hash.html"><span class="prevnext-text">General Purpose Hashing</span></a></span>
        </div>
        

<h2>Index
</h2>
<p><a href="#hash/bytes">hash/bytes</a><span class="divider"> </span><a href="#hash/bytes-max">hash/bytes-max</a><span class="divider"> </span><a href="#hash/bytes-min">hash/bytes-min</a><span class="divider"> </span><a href="#hash/context-bytes">hash/context-bytes</a><span class="divider"> </span><a href="#hash/final">hash/final</a><span class="divider"> </span><a href="#hash/hash">hash/hash</a><span class="divider"> </span><a href="#hash/key-bytes">hash/key-bytes</a><span class="divider"> </span><a href="#hash/keygen">hash/keygen</a><span class="divider"> </span><a href="#hash/new-state">hash/new-state</a><span class="divider"> </span><a href="#hash/update">hash/update</a><span class="divider"> </span><a href="#kdf/bytes-max">kdf/bytes-max</a><span class="divider"> </span><a href="#kdf/bytes-min">kdf/bytes-min</a><span class="divider"> </span><a href="#kdf/context-bytes">kdf/context-bytes</a><span class="divider"> </span><a href="#kdf/derive-from-key">kdf/derive-from-key</a><span class="divider"> </span><a href="#kdf/key-bytes">kdf/key-bytes</a><span class="divider"> </span><a href="#kdf/keygen">kdf/keygen</a><span class="divider"> </span><a href="#kx/keygen">kx/keygen</a><span class="divider"> </span><a href="#kx/kk-packet-1-bytes">kx/kk-packet-1-bytes</a><span class="divider"> </span><a href="#kx/kk-packet-2-bytes">kx/kk-packet-2-bytes</a><span class="divider"> </span><a href="#kx/kk1">kx/kk1</a><span class="divider"> </span><a href="#kx/kk2">kx/kk2</a><span class="divider"> </span><a href="#kx/kk3">kx/kk3</a><span class="divider"> </span><a href="#kx/n-packet-1-bytes">kx/n-packet-1-bytes</a><span class="divider"> </span><a href="#kx/n1">kx/n1</a><span class="divider"> </span><a href="#kx/n2">kx/n2</a><span class="divider"> </span><a href="#kx/psk-bytes">kx/psk-bytes</a><span class="divider"> </span><a href="#kx/public-key-bytes">kx/public-key-bytes</a><span class="divider"> </span><a href="#kx/secret-key-bytes">kx/secret-key-bytes</a><span class="divider"> </span><a href="#kx/session-key-bytes">kx/session-key-bytes</a><span class="divider"> </span><a href="#kx/xx-packet-1-bytes">kx/xx-packet-1-bytes</a><span class="divider"> </span><a href="#kx/xx-packet-2-bytes">kx/xx-packet-2-bytes</a><span class="divider"> </span><a href="#kx/xx-packet-3-bytes">kx/xx-packet-3-bytes</a><span class="divider"> </span><a href="#kx/xx1">kx/xx1</a><span class="divider"> </span><a href="#kx/xx2">kx/xx2</a><span class="divider"> </span><a href="#kx/xx3">kx/xx3</a><span class="divider"> </span><a href="#kx/xx4">kx/xx4</a><span class="divider"> </span><a href="#pwhash/create">pwhash/create</a><span class="divider"> </span><a href="#pwhash/derive-static-key">pwhash/derive-static-key</a><span class="divider"> </span><a href="#pwhash/deterministic">pwhash/deterministic</a><span class="divider"> </span><a href="#pwhash/keygen">pwhash/keygen</a><span class="divider"> </span><a href="#pwhash/reencrypt">pwhash/reencrypt</a><span class="divider"> </span><a href="#pwhash/upgrade">pwhash/upgrade</a><span class="divider"> </span><a href="#pwhash/verify">pwhash/verify</a><span class="divider"> </span><a href="#random/buf">random/buf</a><span class="divider"> </span><a href="#random/buf-deterministic">random/buf-deterministic</a><span class="divider"> </span><a href="#random/ratchet">random/ratchet</a><span class="divider"> </span><a href="#random/reseed">random/reseed</a><span class="divider"> </span><a href="#random/seed-bytes">random/seed-bytes</a><span class="divider"> </span><a href="#random/u32">random/u32</a><span class="divider"> </span><a href="#random/uniform">random/uniform</a><span class="divider"> </span><a href="#secretbox/context-bytes">secretbox/context-bytes</a><span class="divider"> </span><a href="#secretbox/decrypt">secretbox/decrypt</a><span class="divider"> </span><a href="#secretbox/encrypt">secretbox/encrypt</a><span class="divider"> </span><a href="#secretbox/header-bytes">secretbox/header-bytes</a><span class="divider"> </span><a href="#secretbox/key-bytes">secretbox/key-bytes</a><span class="divider"> </span><a href="#secretbox/keygen">secretbox/keygen</a><span class="divider"> </span><a href="#secretbox/probe-bytes">secretbox/probe-bytes</a><span class="divider"> </span><a href="#secretbox/probe-create">secretbox/probe-create</a><span class="divider"> </span><a href="#secretbox/probe-verify">secretbox/probe-verify</a><span class="divider"> </span><a href="#sign/bytes">sign/bytes</a><span class="divider"> </span><a href="#sign/context-bytes">sign/context-bytes</a><span class="divider"> </span><a href="#sign/create">sign/create</a><span class="divider"> </span><a href="#sign/final-create">sign/final-create</a><span class="divider"> </span><a href="#sign/final-verify">sign/final-verify</a><span class="divider"> </span><a href="#sign/keygen">sign/keygen</a><span class="divider"> </span><a href="#sign/keygen-deterministic">sign/keygen-deterministic</a><span class="divider"> </span><a href="#sign/new-state">sign/new-state</a><span class="divider"> </span><a href="#sign/public-key-bytes">sign/public-key-bytes</a><span class="divider"> </span><a href="#sign/secret-key-bytes">sign/secret-key-bytes</a><span class="divider"> </span><a href="#sign/seed-bytes">sign/seed-bytes</a><span class="divider"> </span><a href="#sign/update">sign/update</a><span class="divider"> </span><a href="#sign/verify">sign/verify</a><span class="divider"> </span><a href="#util/++">util/++</a><span class="divider"> </span><a href="#util/=">util/=</a><span class="divider"> </span><a href="#util/bin2hex">util/bin2hex</a><span class="divider"> </span><a href="#util/compare">util/compare</a><span class="divider"> </span><a href="#util/hex2bin">util/hex2bin</a><span class="divider"> </span><a href="#util/memzero">util/memzero</a><span class="divider"> </span><a href="#util/pad">util/pad</a><span class="divider"> </span><a href="#util/unpad">util/unpad</a></p><h2>Reference
</h2>
<div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/bytes">hash/bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a generic, simple hash.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/bytes-max">hash/bytes-max</a></span><span class="binding-type">number <code class="binding-realval">65535</code></span></div><p>Maximum number of bytes allowed when creating a keyed hash.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/bytes-min">hash/bytes-min</a></span><span class="binding-type">number <code class="binding-realval">16</code></span></div><p>Minimum number of bytes allowed when creating a keyed hash.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/context-bytes">hash/context-bytes</a></span><span class="binding-type">number <code class="binding-realval">8</code></span></div><p>Number of bytes required in context buffer for hashing.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/final">hash/final</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">hash/final</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">len</span>)</code></pre><p>Get the final hash after digesting all of the input as a string. The resulting hash will be a string of length len.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/hash">hash/hash</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">hash/hash</span> <span class="mdzsyn-symbol">size</span> <span class="mdzsyn-symbol">input</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">key</span>)</code></pre><p>Hash some input bytes into an output string of length size. Optionally provide a key that can be used to generate different hashes on the same input.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/key-bytes">hash/key-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a key required for hashing.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/keygen">hash/keygen</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">hash/keygen</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">buf</span>)</code></pre><p>Generate a key suitable for use in hashing. The key is a buffer of at least 32 bytes. If a buffer buf is provided, the first 32 bytes of buf will be set to a new random key. Returns a key buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/new-state">hash/new-state</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">hash/new-state</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">key</span>)</code></pre><p>Create a new hash-state. Takes a context ctx and a key and returns a new abstract type, jhydro/hash-state. Both ctx and key should be byte sequences, of at least lengths 8 and 32 respectively. Returns the new state.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="hash/update">hash/update</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">hash/update</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">bytes</span>)</code></pre><p>Add more bytes to the hash state. Returns the modified state</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kdf/bytes-max">kdf/bytes-max</a></span><span class="binding-type">number <code class="binding-realval">65535</code></span></div><p>Maximum number of bytes allowed in kdf generated key.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kdf/bytes-min">kdf/bytes-min</a></span><span class="binding-type">number <code class="binding-realval">16</code></span></div><p>Minimum number of bytes allowed in kdf generated key.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kdf/context-bytes">kdf/context-bytes</a></span><span class="binding-type">number <code class="binding-realval">8</code></span></div><p>Number of bytes in context argument to jhydro/kdf functions.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kdf/derive-from-key">kdf/derive-from-key</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kdf/derive-from-key</span> <span class="mdzsyn-symbol">sublen</span> <span class="mdzsyn-symbol">subid</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">key</span>)</code></pre><p>Generate a subkey from a master key. Takes a subid, which is a positive integer that represents the key id, and ctx, which is an 8 byte string that is usually an application constant. Finally, the last parameter is the master key. Returns a string of length sublen.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kdf/key-bytes">kdf/key-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a kdf key.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kdf/keygen">kdf/keygen</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kdf/keygen</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">buf</span>)</code></pre><p>Generate a key for use in KDFs. Returns the modified buf if provided, or a new random buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/keygen">kx/keygen</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/keygen</span>)</code></pre><p>Generate a keypair for use key exchanges. Contains both a public key and a secret key. Returns a struct with two entries, and :secret-key and a :public-key.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/kk-packet-1-bytes">kx/kk-packet-1-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in the first packet sent in the KK variant key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/kk-packet-2-bytes">kx/kk-packet-2-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in the second packet sent in the KK variant key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/kk1">kx/kk1</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/kk1</span> <span class="mdzsyn-symbol">packet-1</span> <span class="mdzsyn-symbol">static-pk</span> <span class="mdzsyn-symbol">pk</span> <span class="mdzsyn-symbol">sk</span>)</code></pre><p>Generate the first packet for the KK variant key exchange. Returns a jhydro/ks-state abstract which contains some useful state for the key exchange. static-pk is the peer's public key, and pk and sk are the client's public and secret keys. Modifies the buffer packet-1 by appending new data.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/kk2">kx/kk2</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/kk2</span> <span class="mdzsyn-symbol">packet-2</span> <span class="mdzsyn-symbol">packet-1</span> <span class="mdzsyn-symbol">static-pk</span> <span class="mdzsyn-symbol">pk</span> <span class="mdzsyn-symbol">sk</span>)</code></pre><p>Generate the second packet and a session keypair in the KK variant key exchange. packet-2 is a buffer to put the new packet in. packet-1 is the packet received from the peer. static-pk is the other peer's public key, and pk and sk are the local client's public and secret keys. Returns a session keypair, which is a struct of two entries, :rx and :tx.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/kk3">kx/kk3</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/kk3</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">packet-2</span> <span class="mdzsyn-symbol">pk</span> <span class="mdzsyn-symbol">sk</span>)</code></pre><p>Generate a session key on the initiating peer in the KK variant key exchange. state is the jhydro/kx-state from step 1, packet-2 is the packet from step 2, and pk and sk are the local client's public and secret keys. Returns a session keypair, which is a struct of two entries, :rx and :tx.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/n-packet-1-bytes">kx/n-packet-1-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in the first packet sent in the N variant key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/n1">kx/n1</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/n1</span> <span class="mdzsyn-symbol">packet-buf</span> <span class="mdzsyn-symbol">psk</span> <span class="mdzsyn-symbol">peer-pk</span>)</code></pre><p>Create a session key and generate a packet on the client as the first step in the N variant key exchange. Also take a pre-shared key, and the peer's public key. Returns a session key as a struct of two entries, :tx and :rx, which are the transmit and receive keys for communicating with the peer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/n2">kx/n2</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/n2</span> <span class="mdzsyn-symbol">packet1</span> <span class="mdzsyn-symbol">psk</span> <span class="mdzsyn-symbol">pk</span> <span class="mdzsyn-symbol">sk</span>)</code></pre><p>Create a session key as the second step in the N variant key exchange on the server. packet1 is what kx/n1 put into a buffer (packet-buf), psk is a pre-shared key, pk is the server's public key, and sk is the server's secret key. Returns a session keypair that is a mirror of what is on the client, but :tx and :rx are swapped.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/psk-bytes">kx/psk-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a pre-shared key for key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/public-key-bytes">kx/public-key-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a public key intended for key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/secret-key-bytes">kx/secret-key-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a secret key intended for key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/session-key-bytes">kx/session-key-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a session key (tx or rx key). These keys are used to encrypt and decrypt messages between two peers.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/xx-packet-1-bytes">kx/xx-packet-1-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in the first packet sent in the XX variant key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/xx-packet-2-bytes">kx/xx-packet-2-bytes</a></span><span class="binding-type">number <code class="binding-realval">80</code></span></div><p>Number of bytes in the second packet sent in the XX variant key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/xx-packet-3-bytes">kx/xx-packet-3-bytes</a></span><span class="binding-type">number <code class="binding-realval">48</code></span></div><p>Number of bytes in the third packet sent in the XX variant key exchange.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/xx1">kx/xx1</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/xx1</span> <span class="mdzsyn-symbol">packet-1</span> <span class="mdzsyn-symbol">psk</span>)</code></pre><p>First step in XX variant key exchange. Takes in a packet buffer and pre-shared key, and generates the first packet. Also returns a jhydro/kx-state for use in future steps.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/xx2">kx/xx2</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/xx2</span> <span class="mdzsyn-symbol">packet-2</span> <span class="mdzsyn-symbol">packet-1</span> <span class="mdzsyn-symbol">psk</span> <span class="mdzsyn-symbol">pk</span> <span class="mdzsyn-symbol">sk</span>)</code></pre><p>Second step in XX variant key exchange. Takes a buffer for writing packet number 2 too, packet 1, a pre-shared key, and the local public key and secret key. Writes the second packet to packet-2, and returns a jhydro/kx-state.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/xx3">kx/xx3</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/xx3</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">packet-3</span> <span class="mdzsyn-symbol">packet-2</span> <span class="mdzsyn-symbol">psk</span> <span class="mdzsyn-symbol">pk</span> <span class="mdzsyn-symbol">sk</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">peer-pk</span>)</code></pre><p>Third step in XX variant key exchange. Takes the state returned from kx/xx1, a buffer packet-3 to write the final packet into, the packet packet-2 send from the other peer, a pre-shared key psk, and the public and secret keys of the local machine. Optionally takes a buffer to write the remote peer's public key into, so you can reject connections if they do not match the expected public key. Returns a session keypair, which is a struct with two entries, :rx and :tx.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="kx/xx4">kx/xx4</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">kx/xx4</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">packet-3</span> <span class="mdzsyn-symbol">psk</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">peer-pk</span>)</code></pre><p>Fourth and final step in the XX key exchange variant. Takes the state returned from kx/xx2, the packet received from kx/xx3, and a pre-shared key psk. Optionally takes a buffer peer-pk, which will have the remote peer's public key written appended to it. Returns a session keypair, which contains :tx and :rx entires.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="pwhash/create">pwhash/create</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">pwhash/create</span> <span class="mdzsyn-symbol">passwd</span> <span class="mdzsyn-symbol">masterkey</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">opslimit</span> <span class="mdzsyn-symbol">memlimit</span> <span class="mdzsyn-symbol">threads</span>)</code></pre><p>Hash a password and get a blob that can be safely stored in a database. The returned result is a 128 byte string. Can take optional parameters to tune the difficulty of the hash.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="pwhash/derive-static-key">pwhash/derive-static-key</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">pwhash/derive-static-key</span> <span class="mdzsyn-symbol">keylen</span> <span class="mdzsyn-symbol">stored</span> <span class="mdzsyn-symbol">passwd</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">master-key</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">opslimit</span> <span class="mdzsyn-symbol">memlimit</span> <span class="mdzsyn-symbol">threads</span>)</code></pre><p>Derive a static key for used in cryptographic applications from a hashed password and other entropy (kept in stored). Returns a string with keylen bytes.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="pwhash/deterministic">pwhash/deterministic</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">pwhash/deterministic</span> <span class="mdzsyn-symbol">hlen</span> <span class="mdzsyn-symbol">passwd</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">master-key</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">opslimit</span> <span class="mdzsyn-symbol">memlimit</span> <span class="mdzsyn-symbol">threads</span>)</code></pre><p>Hash a password to produce a high entropy key. The returned hashed password is a string of length hlen.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="pwhash/keygen">pwhash/keygen</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">pwhash/keygen</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">buf</span>)</code></pre><p>Generate a master key for use in hashing passwords. The master key is used to encrypt all hashed passwords for an extra level of security. Returns a buffer with the new key.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="pwhash/reencrypt">pwhash/reencrypt</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">pwhash/reencrypt</span> <span class="mdzsyn-symbol">stored</span> <span class="mdzsyn-symbol">masterkey</span> <span class="mdzsyn-symbol">new-masterkey</span>)</code></pre><p>Re-encrypt a hashed password under a new master key without needing the original password, only the previously hashed password and master key. Returns the new hashed password as a string.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="pwhash/upgrade">pwhash/upgrade</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">pwhash/upgrade</span> <span class="mdzsyn-symbol">stored</span> <span class="mdzsyn-symbol">masterkey</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">opslimit</span> <span class="mdzsyn-symbol">memlimit</span> <span class="mdzsyn-symbol">threads</span>)</code></pre><p>Change the encryption parameters of a key to make decrypting faster or slower. This can be used to scale difficulty of password hashing in the event of hardware advancements. Returns the new password hash as a string.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="pwhash/verify">pwhash/verify</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">pwhash/verify</span> <span class="mdzsyn-symbol">stored</span> <span class="mdzsyn-symbol">passwd</span> <span class="mdzsyn-symbol">master-key</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">opslimit</span> <span class="mdzsyn-symbol">memlimit</span> <span class="mdzsyn-symbol">threads</span>)</code></pre><p>Check if a password matches a stored password hash. Hashing options must be the same as the ones used to created the stored hash.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="random/buf">random/buf</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">random/buf</span> <span class="mdzsyn-symbol">buf</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">size</span>)</code></pre><p>Fill a buffer with random bytes. If size is not provided, will clear and fill the given buffer. If size is provided, will append size random bytes to the buffer. Alternatively, you can provide just the size argument, and a new randomized buffer will be returned.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="random/buf-deterministic">random/buf-deterministic</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">random/buf-deterministic</span> <span class="mdzsyn-symbol">buf</span> <span class="mdzsyn-symbol">len</span> <span class="mdzsyn-symbol">seed</span>)</code></pre><p>Generate len random bytes and push them into a buffer buf. seed is a byte sequence of at least 32 bytes that initializes the state of the RNG. Returns the modified buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="random/ratchet">random/ratchet</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">random/ratchet</span>)</code></pre><p>Increment the internal state of the RNG.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="random/reseed">random/reseed</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">random/reseed</span>)</code></pre><p>Provide a new random seed for the internal RNG.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="random/seed-bytes">random/seed-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a seed for the RNG.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="random/u32">random/u32</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">random/u32</span>)</code></pre><p>Generate a psuedo random 32 bit unsigned integer</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="random/uniform">random/uniform</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">random/uniform</span> <span class="mdzsyn-symbol">top</span>)</code></pre><p>Generate a random 32 bit unsigned integer less than top.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/context-bytes">secretbox/context-bytes</a></span><span class="binding-type">number <code class="binding-realval">8</code></span></div><p>Number of bytes in a context for secretbox functions.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/decrypt">secretbox/decrypt</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">secretbox/decrypt</span> <span class="mdzsyn-symbol">cipher-text</span> <span class="mdzsyn-symbol">msg-id</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">key</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">buf</span>)</code></pre><p>Decrypt a cipher text that was produced with secretbox/encrypt. msg-id, ctx, and key must be the same as those used to encrypt the message. An optional buffer can be used to contain the plain text, otherwise a new buffer is created. Returns a buffer containing the plain text.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/encrypt">secretbox/encrypt</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">secretbox/encrypt</span> <span class="mdzsyn-symbol">msg</span> <span class="mdzsyn-symbol">msg-id</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">key</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">buf</span>)</code></pre><p>Encrypt a message with a secretbox key and return the cipher text in a buffer. Also requires a message id, which is an integer, and a ctx, which is a non-secret byte-sequence. Lastly, requires a secret symmetric key for encryption. An optional buffer will prevent Janet from creating a new buffer, and instead append to and return the provided buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/header-bytes">secretbox/header-bytes</a></span><span class="binding-type">number <code class="binding-realval">36</code></span></div><p>Number of bytes in the header of an encrypted message.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/key-bytes">secretbox/key-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a secretbox key.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/keygen">secretbox/keygen</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">secretbox/keygen</span>)</code></pre><p>Generate a key suitable for secretbox. The returned key is a 32 byte buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/probe-bytes">secretbox/probe-bytes</a></span><span class="binding-type">number <code class="binding-realval">16</code></span></div><p>Number of bytes in a secretbox probe.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/probe-create">secretbox/probe-create</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">secretbox/probe-create</span> <span class="mdzsyn-symbol">cipher-text</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">key</span>)</code></pre><p>Create a probe for some cipher text created by secretbox/encrypt. The resulting probe is a constant length string that can be used to verify if cipher text is valid before decrypting the entire text. Returns a string.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="secretbox/probe-verify">secretbox/probe-verify</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">secretbox/probe-verify</span> <span class="mdzsyn-symbol">probe</span> <span class="mdzsyn-symbol">cipher-text</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">key</span>)</code></pre><p>Use a probe produced by secretbox/probe-create to check if some cipher text is genuine. If the cipher text is not forged or tampered with, returns true, otherwise false. Genuine cipher text can then be decrypted. Returns a boolean.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/bytes">sign/bytes</a></span><span class="binding-type">number <code class="binding-realval">64</code></span></div><p>Number of bytes in a signature.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/context-bytes">sign/context-bytes</a></span><span class="binding-type">number <code class="binding-realval">8</code></span></div><p>Number of bytes needed for a signature context.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/create">sign/create</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/create</span> <span class="mdzsyn-symbol">msg</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">sk</span>)</code></pre><p>Create a new sigature from a message, ctx, and secret key. The message can be any byte sequence, the context ctx should be a byte sequence of at least 8 bytes, and the secret key sk should be secret key as generated from sign/keygen or sign/keygen-deterministic. Returns a signature, which is a 64 byte string.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/final-create">sign/final-create</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/final-create</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">sk</span>)</code></pre><p>Create a signature from the sign-state. Takes a jhydro/sign-state state and a secret key sk. Returns the signature and also modifies the state.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/final-verify">sign/final-verify</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/final-verify</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">csig</span> <span class="mdzsyn-symbol">pk</span>)</code></pre><p>Verify a signature with a public key. Given a sign-state state, signature csig, and public key pk, return true if csig is valid, otherwise false.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/keygen">sign/keygen</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/keygen</span>)</code></pre><p>Create a random key pair for public key signing. Returns a struct containing a :public-key and a :secret-key as strings.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/keygen-deterministic">sign/keygen-deterministic</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/keygen-deterministic</span> <span class="mdzsyn-symbol">seed</span>)</code></pre><p>Create a key pair from a seed. Seed should be a byte sequence of at least 32 bytes; random/buf should work well. Returns a struct of two key value pairs, a :secret-key and a :public-key. Each key is a string.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/new-state">sign/new-state</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/new-state</span> <span class="mdzsyn-symbol">ctx</span>)</code></pre><p>Create a new state machine for generating a signature. A state machine allows processing a message in chunks to generate a signature. A string ctx of at least 8 bytes is also required, and can be a hard coded string. Returns a new jhydro/sign-state.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/public-key-bytes">sign/public-key-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a public key for making signatures.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/secret-key-bytes">sign/secret-key-bytes</a></span><span class="binding-type">number <code class="binding-realval">64</code></span></div><p>Number of bytes in a secret key for making signatures.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/seed-bytes">sign/seed-bytes</a></span><span class="binding-type">number <code class="binding-realval">32</code></span></div><p>Number of bytes in a seed for generating a key.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/update">sign/update</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/update</span> <span class="mdzsyn-symbol">state</span> <span class="mdzsyn-symbol">msg</span>)</code></pre><p>Process a message chunk for generating a signature. Returns the modified signature state.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="sign/verify">sign/verify</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">sign/verify</span> <span class="mdzsyn-symbol">csig</span> <span class="mdzsyn-symbol">msg</span> <span class="mdzsyn-symbol">ctx</span> <span class="mdzsyn-symbol">pk</span>)</code></pre><p>Check a signature to determine if a message is authentic. csig is the signature as generated by sign/create or sign/final-create, msg is the message that we are checking, ctx is the context string, and pk is the public key. Returns a boolean, true if the signature is valid, false otherwise.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/++">util/++</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/++</span> <span class="mdzsyn-coresym">buffer</span>)</code></pre><p>Increment a buffer, treating it as a little endian large integer. If the increment results in an overflow, sets the buffer to all zero bytes. Returns the modified buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/=">util/=</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/=</span> <span class="mdzsyn-symbol">lhs</span> <span class="mdzsyn-symbol">rhs</span>)</code></pre><p>Compare the contents of two equal length buffers without early returns, which helps prevent side channel attacks. This is the function that should be used for comparing two buffers with cryptographic content. If the two buffers are of different lengths, returns early. Returns a boolen.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/bin2hex">util/bin2hex</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/bin2hex</span> <span class="mdzsyn-symbol">bin</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">hex</span>)</code></pre><p>Convert binary data into hexidecimal. The hex representation of bin, the input buffer, is converted to a ascii hexidecimal and put in the buffer hex, or a new buffer if hex is not supplied. Returns hex or a new buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/compare">util/compare</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/compare</span> <span class="mdzsyn-symbol">lhs</span> <span class="mdzsyn-symbol">rhs</span>)</code></pre><p>Compare two buffers without early returns to help prevent side channel attacks. Returns an integer -1, 0, or 1.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/hex2bin">util/hex2bin</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/hex2bin</span> <span class="mdzsyn-symbol">hex</span> <span class="mdzsyn-symbol">&amp;opt</span> <span class="mdzsyn-symbol">bin</span> <span class="mdzsyn-symbol">ignore</span>)</code></pre><p>Convert a hexidecimal string to binary data. Can provide an optional bin to write into instead of creating a new buffer, and also a string of characters to ignore while reading hex. Returns the buffer bin or a new buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/memzero">util/memzero</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/memzero</span> <span class="mdzsyn-coresym">buffer</span>)</code></pre><p>Clear memory in a buffer to 0, not changing the size of the buffer. Returns the modified buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/pad">util/pad</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/pad</span> <span class="mdzsyn-coresym">buffer</span> <span class="mdzsyn-symbol">blocksize</span>)</code></pre><p>Pad a buffer according to the ISO/IEC 7816-4 algorithm. Returns the modified buffer.</p></div><div class="docstring"><div class="binding-wrap"><span class="binding"><a id="util/unpad">util/unpad</a></span><span class="binding-type">cfunction</span></div><pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">util/unpad</span> <span class="mdzsyn-coresym">buffer</span> <span class="mdzsyn-symbol">blocksize</span>)</code></pre><p>Unpad a buffer padded via util/pad. Returns the modifed buffer.</p></div>
        <div class="prevnext-bar">
          <span class="prev"><a href="../index.html"><span class="prevnext-text">Jhydro</span></a></span>
          <span class="next"><a href="hash.html"><span class="prevnext-text">General Purpose Hashing</span></a></span>
        </div>
      </div>
    </div>
    <script charset="utf-8">
      function toggleToc() {
        var toggler = document.getElementById('toc-toggle');
        var wrapper = document.querySelector('.toc');
        wrapper.classList.toggle('toc-hidden');
        toggler.classList.toggle('open');
        window.localStorage.setItem('show-toc', toggler.classList.contains('open'));
      }
      function addTocToggle() {
        var el = document.getElementById('toc-toggle');
        el.addEventListener('click', toggleToc);
      }
      window.addEventListener('DOMContentLoaded', addTocToggle);
      if (window.localStorage.getItem('show-toc') === 'true') {
        toggleToc()
      }
    </script>
    <footer>
      <div class="content-wrapper">
        Copyright &copy; Calvin Rose 2019
      </div>
    </footer>
  </body>
</html>
